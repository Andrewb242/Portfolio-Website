{
    "projects":[
        {
            "title": "Malloc Implementation",
            "github": "https://github.com/Andrewb242/Malloc-Implementation-in-C",
            "description": "This project involves the design and implementation of a dynamic memory allocator in C, providing custom versions of malloc, free, and realloc with a focus on efficiency and robust memory management. The allocator employs multiple optimization techniques, including segregated free lists (bins) to categorize free blocks by size for faster allocation, as well as block splitting and coalescing to minimize fragmentation and maximize heap utilization. Distinct data structures are utilized to manage free and allocated blocks, enabling precise tracking and manipulation of memory regions. A compact metadata layout integrates bitmaps for efficient storage of block sizes and allocation flags, reducing overhead while supporting rapid access to block information. In addition to core allocation functionality, the project features an extensive debugging infrastructure, incorporating detailed debug print statements throughout the allocator to trace internal operations and diagnose issues. Significant emphasis was placed on using the GDB debugger to analyze heap state, identify memory corruption, and validate allocator behavior under various workloads. The allocator was carefully tested and refined to ensure correctness, performance, and stability, offering insight into low-level memory management techniques and the complexities of system-level C programming."
        },
        {
            "title": "Maze Algorithm Exploration in C",
            "github": "https://github.com/Andrewb242/Maze-Algorithms.git",     
            "description": "This project involves the design and implementation of a maze generation system in C, exploring and c omparing multiple algorithmic approaches to procedural maze creation. The system incorporates several well-known maze generation algorithms, including Depth-First Search (DFS) backtracking, Eller's algorithm, and Kruskal's algorithm, each offering distinct strategies for constructing complex and solvable mazes. The implementation emphasizes both algorithmic correctness and performance efficiency, providing dynamically sized mazes that are guaranteed to be fully connected and without isolated regions. The project includes visual representations of the mazes, allowing users to observe the step-by-step construction process for each algorithm. Additionally, the system supports configurable parameters such as maze dimensions and algorithm selection, enabling comparative analysis of algorithm behavior and runtime characteristics. Through careful management of memory and data structures such as disjoint sets and position structures. the implementation ensures reliable and scalable maze generation for a variety of applications."
        },
        {
            "title": "Greek Vocabulary Website",
            "github": "https://github.com/Andrewb242/greek-vocab.git",
            "description": "This project involves the design and development of an interactive Ancient Greek study tool using the React framework, aimed at enhancing language learning through an engaging and user-friendly interface. The application features a customizable, searchable dictionary that allows users to quickly look up vocabulary entries, along with stylized charts presenting grammatical paradigms in a clear and visually accessible format. An interactive flashcard game is integrated to reinforce vocabulary acquisition, providing randomized practice sessions with instant feedback to support active recall and retention. The interface is enriched with a custom-designed icon and thoughtful visual styling to create an aesthetically cohesive and intuitive user experience. The project leverages modern front-end development practices, including component-based architecture, responsive design, and efficient state management, to deliver a performant and scalable application. This personal project provided valuable experience in full-stack application design, user interaction design, and the use of modern JavaScript libraries to build educational tools tailored to niche subject areas."
        },
        {
            "title": "Mini Shell Implementation",
            "github": "https://github.com/Andrewb242/Mini-Shell-Implementation#",
            "description": "This project involves the implementation of a miniature Unix-like shell in C, providing core functionality for command execution and process management within an interactive environment. The shell supports built-in commands such as cd and exit, along with advanced features including file input/output redirection, pipelines for connecting multiple commands, and parallel command execution using operators such as | and &. While the project did not include the implementation of the command parser, the focus was placed on executing parsed command structures, managing child processes, handling file descriptors for redirection, and ensuring correct synchronization and resource cleanup during concurrent execution. The shell was designed to handle various execution scenarios robustly, including sequential and parallel workflows, while maintaining responsiveness and stability. Extensive testing and debugging were conducted to ensure proper behavior in diverse command combinations, deepening understanding of process control, inter-process communication, and Unix system calls such as fork, exec, dup2, and wait."
        },
        {
            "title": "Concurancy Project",
            "github": "https://github.com/Andrewb242/Concurancy-Project",
            "description": "This project involves the implementation of a thread-safe channel communication system in C, utilizing POSIX threads (pthreads) to enable safe and efficient data transfer between concurrent threads. The system provides both blocking and non-blocking functions for reading from and writing to a shared channel buffer, facilitating flexible inter-thread communication patterns. Synchronization is achieved through the use of mutexes to protect shared resources and condition variables to coordinate signaling and waiting between producer and consumer threads. Blocking operations ensure that threads wait appropriately when the buffer is full or empty, while non-blocking variants return immediately if the operation cannot proceed, allowing for responsive and adaptable thread interactions. The project emphasizes correct handling of race conditions, deadlock prevention, and resource management, with careful attention to the semantics of condition variable signaling and spurious wakeups. Extensive testing was conducted to validate the behavior of the channel under various concurrency scenarios, providing practical experience in designing and debugging multithreaded systems with fine-grained synchronization mechanisms."

        }, 
        {
            "title": "Pipelined MIPS Processor",
            "github": "https://github.com/Andrewb242/Pipelined-Processor.git",
            "description": "This project involves the design and implementation of a pipelined MIPS processor in Verilog, capable of executing I-type and R-type instructions. The processor employs a 5-stage pipeline consisting of IF (Instruction Fetch), ID (Instruction Decode), EX (Execute), MEM (Memory Access), and WB (Write-back) stages to enable efficient instruction processing. To enhance the performance of the pipeline, data forwarding is implemented to resolve data hazards by forwarding results from later stages back to earlier ones without waiting for memory write-back. Additionally, the processor includes stalls to handle control hazards and prevent incorrect instruction execution when branch instructions are encountered or when dependencies between instructions are detected. The processor can execute a subset of MIPS instructions, including arithmetic, logical, and memory operations. The system ensures proper handling of data dependencies, minimizing pipeline stalls while maintaining the correct instruction flow."
        },
        {
            "title": "JBOD System with Network Communication and Cache",
            "github": "https://github.com/Andrewb242/JBOD-System-C.git",
            "description": "This project involved the development of a Just a Bunch Of Disks (JBOD) system programmed in C, designed to manage multiple storage devices and facilitate data reading and writing. The system features network communication using file descriptors, enabling communication between the JBOD server and client applications over a network. The project included the implementation of a functioning cache to enhance performance, where data was temporarily stored in memory through dynamic memory allocation. This allowed for efficient data retrieval and reduced access times to frequently used data. The JBOD system also supports basic read and write commands, enabling users to interact with the storage devices, perform data operations, and manage files. It is important to note that this was a school project, and while I implemented key components of the system, the JBOD server file (handling the server-side logic) was provided as part of the course materials and was not written by me."
        },
        {
            "title": "Course Scheduler with GUI and SQL Database Integration",
            "github": "https://github.com/Andrewb242/Course-Scheduler-CMPSI-221.git",
            "description": "This project involves the development of a Course Scheduler application written in Java, designed to help students plan and manage their academic schedules. The system features a fully implemented Graphical User Interface (GUI), providing an intuitive and user-friendly platform for interacting with the application. The backend of the system is powered by a relational database, where SQL is used for efficient data storage and retrieval. The database manages various elements such as course details, student schedules, and semester information, ensuring that all data is securely stored and easily accessible. Users can add, update, and view their courses, and check course availability, all while the system maintains consistency and integrity through proper database management. This project demonstrates proficiency in both Java GUI programming and SQL database integration."
        },
        {
            "title": "Lexer and Parser with Type Matching and Scope Checking in Python",
            "github": "https://github.com/Andrewb242/Python-Parser.git",
            "description": "This project involves the development of a lexical analyzer and parser implemented in Python, designed to process a custom programming language with static typing and block-level scoping. The system follows a two-stage compilation process, beginning with lexical analysis to convert source code into tokens, followed by parsing to validate syntax and semantics. The lexer identifies and categorizes language constructs including keywords, identifiers, literals, and operators, while maintaining precise error tracking for invalid patterns. The parser implements recursive descent techniques to construct an abstract syntax tree, enforcing type safety through static checking and maintaining symbol tables for scope management. To ensure code correctness, the system implements comprehensive error detection for type mismatches and scope violations, preventing issues such as invalid variable access and improper type assignments. The parser supports fundamental programming constructs including variable declarations, control flow statements, and expressions, while enforcing proper scoping rules to handle variable shadowing and block-level scope boundaries. The implementation emphasizes clean error reporting, providing detailed feedback for both syntactic and semantic errors encountered during the compilation process. It is important to note that this was a school project. Only the logic in the file 'Parser.py' was written by me"
        }

    ]
}